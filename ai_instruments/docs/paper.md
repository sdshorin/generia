
(внутренние комментарии. Зачем ты смотришь файлы в истории гита?)

- LangChain, LangGraph - это аналоги Chain-of-Thought (CoT), добавить в диплом


особенности написания с ИИ
- постоянно улучшаются инструменты (claude code, Claude 4, ChatGPT o3)
- Но некоторые инструементы исчезают - Galileo был выкуплен гуглом и переведен на Gemini 2.5, из-за чего большинство инструментов отключилось, и продуктом стало невозможно пользоваться (так как отключили подписки, а новый продукт на основе Gemini был опубликован только как прототип - и генерировал дизайн куда хуже - не использовал фигму, не подбирал дизайн, и в целом в плане дизайна создавал сайты на уровне обычных моделей, а не специализированных инструментов для UI/UX типа Galileo )


Задачи и цели
- Проверить, развились ли системы генерации кода с ИИ до той степени, что с их помощью можно писать большие и серьезные проекты. И если да - понять, как будет выглядеть процесс разработки в будущем, и выработать методики работы с кодом для такой разработки.
- Проверить гипотезу, что в будущем вместо целой команды разработчиков над проектом будет работать только один человек с множеством ИИ ассистентов (ссылки на статьи что многие стартапы уже работают по такий методике)

Вывод
- возможно
- требуется хорошие "горизонтальные знания" - фронтенд, бэкенд, безопасность, и тд, Computer  science, фундаментальное образование (автор предсказывал это еще 4 года назад, когда ушел с full time работы программистом на бакалвариат)
- Требуется понимания каждой строчки, написанной ИИ (в этом проекте это соблюдается только частично - автор понимает работу фронтенда только в общих чертах)
- Если задача описана без деталей - то ИИ додумывает ее, и часто - не в ту сторону, что планировалось. Если задача описана хорошо - все равно совершает ошибки, поэтому код нужно всегда перепроверять - иначе придется потом искать баг в совершенно незнакомом коде, что занимает много времени (хотя баг был виден на этапе генерации) - (например - код в генераторе мира был с ошибкой в логике - одна из задач предполагала, что некоторые посты могут быть без картинки. Из-за чего возникал непонятный баг, причину которого пришлось долго искать)


Как выбирать модели - SWE Branch

(Какая бывает разработка кода с ИИ - копирование кода через веб интерфпейс модели и работа с файлами(а если ограничение на количество файлов - объединение кода в один документ), или Использование специальных агентов, устройство агентов описано в статье .... )

(нужен специальный раздел, где описана архитектура агентов для написания кода!! нужно пересказать статью - https://arxiv.org/abs/2405.15793 SWE-agent: Agent-Computer Interfaces Enable Automated Software Engineering. Примерно на 2-3 страницы, основные тезисы)

Агенты
claude code - мощно, но дорого (cil)
augment - тоже дорого (если по подписке), но так же имеет собственный движок поиска. Работает более мелкими шагами . работает дольше, следить за процессом генерации кода и проверять его - не так удобно. (форк VScode)
- не переписывает целые файлы за раз как claude code, а работает с маленькими изменениями по несколько строчек
cursor- использует более простые модели, поэтому дешевле, но теряется в больших проектах. (плагин VS Code)



Основные проблемы:
1. детальные промпты (md файлы)
2. ограничение контекста модели на больших проектах - нужно директивно в тз указывать, какие файлы нужно изменить, иначе ИИ агент начинает теряться в коде и забивать контекст (что ухудшает работу модели и увеличивает стоимость)
3. ограниченные знания модели - решается моделями, которые умеют гуглить (chatgpt o3 хорошо справляется с такими вопросами)


чтобы работать с большими проектами и хорошо ориентироваться в коде
- либо использовать встроенные в агента поисковые движки (Agument)
- Либо указывать директивно пути к файлам в промпте
- Либо автоматически генерировать с помощью моделей с большим контекстом README файлы с документацией, которые указывать в промпте

Правила:
- большие детальные промпты на каждый шаг (некотрые примеры промптов - в репозатории)
- всегда - ручная перепроверка кода (с помощью diff - либо в git, либо во встроенном инструменте в самом агенте)



Как выглядит разработка:
- долго пишу промпт и продумываю идею и архитектуру - обсуждая ее с claude и chatgpt в веб-версиях.
- когда в голове складывается решение - пишу большой и подробный md файл с описанием задачи (сслыка на пример файла), а так же пишу сам промпт в отдельном файле или в заметках
- затем копирую эот промпт в агента
- Слежу за процессом генерации и читаю код сразу, как модель его написала. Если генерация пошла не туда - останавливаю ее, и переписываю промпт. (Код перестает быть ценностью, поэтому в процессе работы часто приходится удалять сотни строчек сгенерированного кода и перезапускать задачу - если в коде были архитектурные проблемы). Фокус работы смещается на написание документации
- Компилирую и тестирую код, сообщения о любых ошибках отправляю в тот эе диалог с агентом, в котором уже прогружен весь контекст работы.

Использование русского языка в промпте - хуже, но не так сильно чтобы снижать удобство разработки (нужно найти статьи)

Часто приходится отменять изменения модели. И для этого в Cursor и Agument есть специальные инструменты


 Добавить в диплом:


1. Почему аи генерация - ссылки на рост способностей ИИ, и если этих способностей недостаточно - то на рост вычислительной мощности
2. Chiper.ai - добавить, что есть хороший пример фронтенда и пример просмотра промптов и пример интерфейса
3. Статьи из https://chirper.fun https://chirper.fun/whitepaper.pdf



Переход от kafka к Temporal Workflow Engine

Основная проблема - перезапуск упавших задач и требование выполнения exatcly-one (так как вызовы api дорогие)






